module adder (
    input clk,  // clock
    input rst,  // reset
    output a, //first input to full adder
    output b, //second input to full adder
    output ci, //last input to full adder
    input s, //sum and carry-out output from full adder, to test if output is correct
    input co,
    output testcase[8],
    
    output out_seg,
    output out_sel,
    
    output error
  ) {
  .clk(clk){
  edge_detector edge_detector(#RISE(1), #FALL(0)); //edge_detector to detect rising edge of state_changer
  .rst(rst){
    dff state_changer[27]; //27 bit number, used as a timer. Change state when most significant bit is 1
    fsm state = {ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, ERROR, GOOD}; //all possible combinations of inputs to adder, plus one error state
    multi_seven_seg seg;
    }
  
  }
  always {
    seg.values = {4h0, 4h0, 4h0, 4h0};
    out_seg = ~seg.seg;
    out_sel = ~seg.sel;
    a=0;
    b=0;
    ci=0;
    error = 0;
    testcase = 8b0;
    edge_detector.in = state_changer.q[26]; //most significant bit of 27 bit number
    state_changer.d = state_changer.q + 1; //increase value of state_changer for every clock cycle
    case (state.q){
      state.ZERO:
        a = 0; //set inputs to be 000
        b = 0;
        ci = 0;
        seg.values = {4h00, 4h00, 4h00, 4h00};
        testcase = 8b0;
        if (edge_detector.out){ //most significant bit of state_changer is 1 meaning ~2.68s has passed
          if (co == 0 && s == 0){ //correct outputs from adder circuit, move on to next input
          state.d = state.ONE;
          }
          else {
          state.d = state.ERROR; //incorrect outputs from adder circuit, go into error state
          }
        }
      
      state.ONE:
        a = 1; //set inputs to be 001
        b = 0;
        ci = 0;
        seg.values = {4h01, 4h00, 4h00, 4h00};
        testcase = 8b1;
        if (edge_detector.out){
          if (co == 0 && s == 1){ //correct outputs from adder circuit, move on to next input
          state.d = state.TWO;
          }
          else {
          state.d = state.ERROR; //incorrect outputs from adder circuit, go into error state
          }
        }
        
        
      state.TWO:
        a = 0; //set inputs to be 010
        b = 1;
        ci = 0;
        
        seg.values = {4h00, 4h01, 4h00, 4h00};
        testcase = 8b10;
        if (edge_detector.out){
          if (co == 0 && s == 1){ //correct outputs from adder circuit, move on to next input
          state.d = state.THREE;
          }
          else {
          state.d = state.ERROR; //incorrect outputs from adder circuit, go into error state
          }
        }

      state.THREE:
        a = 1; //set inputs to be 011
        b = 1;
        ci = 0;
        seg.values = {4h01, 4h01, 4h00, 4h00};
        testcase = 8b11;
        if (edge_detector.out){
          if (co == 1 && s == 0){ //correct outputs from adder circuit, move on to next input
          state.d = state.FOUR;
          }
          else {
          state.d = state.ERROR; //incorrect outputs from adder circuit, go into error state
          }      
        }
      
      state.FOUR:
        a = 0; //set inputs to be 100
        b = 0;
        ci = 1;
        seg.values = {4h00, 4h00, 4h01, 4h00};
        testcase = 8b100;
        if (edge_detector.out){
          if (co == 0 && s == 1){ //correct outputs from adder circuit, move on to next input
          state.d = state.FIVE;
          }
          else {
          state.d = state.ERROR; //incorrect outputs from adder circuit, go into error state
          }
        }
        
      state.FIVE:
        a = 1; //set inputs to be 101
        b = 0;
        ci = 1;
        seg.values = {4h01, 4h00, 4h01, 4h00};
        testcase = 8b101;
        if (edge_detector.out){
          if (co == 1 && s == 0){ //correct outputs from adder circuit, move on to next input
          state.d = state.SIX;
          }
          else {
          state.d = state.ERROR; //incorrect outputs from adder circuit, go into error state
          }
        }
        
      state.SIX:
        a = 0; //set inputs to be 110
        b = 1;
        ci = 1;
        seg.values = {4h00, 4h01, 4h01, 4h00};
        testcase = 8b110;
        if (edge_detector.out){
          if (co == 1 && s == 0){ //correct outputs from adder circuit, move on to next input
          state.d = state.SEVEN;
          }
          else {
          state.d = state.ERROR; //incorrect outputs from adder circuit, go into error state
          }
        }
    
      state.SEVEN:
        a = 1; //set inputs to be 111
        b = 1;
        ci = 1;
        seg.values = {4h01, 4h01, 4h01, 4h00};
        testcase = 8b111;
        if (edge_detector.out){
          if (co == 1 && s == 1){ //correct outputs from adder circuit, move on to next input
          state.d = state.GOOD; //go back to first input, 000
          }
          else {
          state.d = state.ERROR; //incorrect outputs from adder circuit, go into error state
          }
        }
      
      state.ERROR:
        seg.values = {4h0d, 4h0d, 4h0e, 4h00};
        error = 1;
        
      state.GOOD:
        seg.values = {4h0a, 4h0b, 4h0b, 4h0c};
        if (edge_detector.out){
          state.d = state.ZERO; //go back to first input, 000
           
        }
        
          
  
}
}
 
}